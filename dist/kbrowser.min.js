class Remote{
/**
       * The constructor function is a special function that is called when a new instance of the class
       * is created.
       * @param url - The URL of the API endpoint.
       */
constructor(e){this.url=e}
/**
       * It fetches the url, then returns the json data
       * @param [options] - The options of the request, such as headers, body, etc.
       * @returns The data from the api.
       */async get(e={}){return fetch(this.url,{method:"GET",...e}).then(async e=>{if(e)return e.json();throw new Error("An error occurred in the api, check the log of the response.")}).then(e=>e).catch(e=>e.message)}
/**
       * It sends a POST request to the url, and returns the response in JSON format
       * @param [options] - The options object is the same as the fetch api, you can pass headers,
       * body, etc.
       * @returns The response of the fetch request.
       */async post(e={}){return fetch(this.url,{method:"POST",...e}).then(e=>{if(e)return e.json();throw new Error("An error occurred in the api, check the log of the response.")}).then(e=>e).catch(e=>e.message)}
/**
       * It sends a POST request to the url, and returns the response in JSON format
       * @param [options] - The options object is the same as the fetch api, you can pass headers,
       * body, etc.
       * @returns The data from the api.
       */async post(e={}){return fetch(this.url,{method:"POST",...e}).then(e=>{if(e)return e.json();throw new Error("An error occurred in the api, check the log of the response.")}).then(e=>e).catch(e=>e.message)}
/**
       * It takes an options object and returns a promise that resolves to a json object
       * @param [options] - {
       * @returns The response of the fetch request.
       */async put(e={}){return fetch(this.url,{method:"PUT",...e}).then(e=>{if(e)return e.json();throw new Error("An error occurred in the api, check the log of the response.")}).then(e=>e).catch(e=>e.message)}
/**
       * It sends a DELETE request to the url and returns the response in JSON format
       * @param [options] - An object that contains the following:
       * @returns The response from the server.
       */async delete(e={}){return fetch(this.url,{method:"DELETE",...e}).then(e=>{if(e)return e.json();throw new Error("An error occurred in the api, check the log of the response.")}).then(e=>e).catch(e=>e.message)}}class Kquery{
/**
       * The constructor function takes in an element and assigns it to the elements property of the
       * object.
       * @param elements - The elements to be added to the array.
       */
constructor(e){this.elements=[e]}
/**
       * If the DOM is ready, run the function, otherwise wait until it is ready and then run the
       * function.
       * @param fn - The function to be executed when the DOM is ready.
       * @returns The function fn is being returned.
       */load(e){return document.addEventListener("DOMContentLoaded",e),this}
/**
       * It returns a NodeList of all the elements that match the selector.
       * @returns The elements that are being returned are the elements that are being selected by the
       * querySelectorAll method.
       */getElements(){return document.querySelectorAll(this.elements)}
/**
       * The function getElement() is a method of the class ElementHandler. It returns the element that
       * is selected by the querySelector() method
       * @returns The element that is being selected.
       */getElement(){return document.querySelector(this.elements)}
/**
       * The event function takes two arguments, the first being the event type and the second being
       * the callback function. The event function then returns the event listener.
       * @param event - The event you want to listen for.
       * @param callback - The function to be called when the event is triggered.
       * @returns The event listener.
       */event(t,r){return this.getElements().forEach(e=>e.addEventListener(t,r)),this}
/**
       * It returns a new Remote object.
       * @param url - The URL of the API.
       * @returns A new instance of the Remote class.
       */remote(e){return new Remote(e)}
/**
       * The function takes a string of HTML as an argument, and inserts it into the innerHTML of each
       * element in the collection.
       * @param html - The HTML to insert.
       * @returns the value of the variable ins.
       */insertHTML(t){return this.getElements().forEach(e=>e.innerHTML+=t),this}
/**
       * The function takes a boolean as an argument and returns a boolean.
       * @param boolean - true or false
       * @returns The return value is the result of the forEach method.
       */disableElement(t){return this.getElements().forEach(e=>e.disabled=t),this}
/**
       * It adds a class to the element.
       * @param className - The class name to add to the element.
       */addClass(e){return this.getElement().classList.add(e),this}
/**
       * The function removes a class from the element.
       * @param className - The class name to be removed from the element.
       */removeClass(e){return this.getElement().classList.remove(e),this}
/**
       * This function replaces the class name of the element with the new class name
       * @param className - The class name to be replaced.
       * @param newClassName - The new class name to replace the old one with.
       */replaceClass(e,t){return this.getElement().classList.replace(e,t),this}
/**
       * This function returns the dataset of the element.
       * @returns The dataset property of the element.
       */getDataSet(){return this.getElement().dataset}
/**
       * For each element in the array of elements, return the dataset of that element.
       * @returns An array of objects.
       * @buged Return undefined
       */getDataSets(){return this.getElements().forEach(e=>e.dataset)}
/**
       * It removes all the children of the element.
       * @returns null.
       */removeChildrens(){return this.getElement().innerHTML="",this}}const $=e=>new Kquery(e);